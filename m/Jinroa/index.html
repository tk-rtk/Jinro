<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>人狼ゲーム（ローカル・パス回し）</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;margin:0;padding:0;background:#0b1220;color:#e6eef8}
  header{background:#0f1724;padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.05)}
  h1{margin:0;font-size:18px}
  main{padding:18px;max-width:1000px;margin:18px auto}
  .card{background:#0f1624;padding:16px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-bottom:12px}
  label{display:block;margin:6px 0}
  input[type=number]{width:70px}
  .roles-list{display:flex;flex-wrap:wrap;gap:8px}
  .role-checkbox{background:#091021;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  button{background:#2b6cb0;color:white;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
  button.secondary{background:#374151}
  .big{font-size:18px;padding:12px 18px}
  .muted{color:#b6c2d6}
  .center{text-align:center}
  .hidden{display:none}
  .player-list{display:flex;gap:6px;flex-wrap:wrap}
  .player-card{background:#071629;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:120px}
  .alive{box-shadow:0 0 0 2px rgba(34,197,94,0.12)}
  .dead{opacity:0.45;text-decoration:line-through}
  .log{background:#06111b;padding:8px;border-radius:8px;max-height:180px;overflow:auto;font-size:13px}
  .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  select{padding:6px;border-radius:6px}
  footer{padding:10px;text-align:center;color:#9fb0d3;font-size:13px}
  .danger{background:#b02a37}
</style>
</head>
<body>
<header>
  <h1>人狼ゲーム（ローカル／端末を回すパス回し方式）</h1>
</header>
<main>
  <div id="setup" class="card">
    <h2>セットアップ</h2>
    <label>プレイヤー人数：
      <input id="playerCount" type="number" min="6" max="12" value="10" />
    </label>
    <label>名前入力（任意・カンマ区切り。空白なら自動で Player1..）</label>
    <textarea id="names" rows="2" style="width:100%;padding:8px;border-radius:8px;background:#061425;color:#e6eef8;border:1px solid rgba(255,255,255,0.04)"></textarea>

    <h3 style="margin-top:10px">役職選択（チェックした役職を含めて配役します。残りは村人で埋めます）</h3>
    <div class="roles-list" id="roleOptions">
      <!-- checkboxes injected by JS -->
    </div>

    <div style="margin-top:12px">
      <button id="assignBtn" class="big">役職を割り当てる → ゲーム開始</button>
      <button id="resetBtn" class="secondary">リセット</button>
    </div>

    <p class="muted" style="margin-top:10px">
      遊び方（簡単）：
      1) 役職を割り当てたら端末を順に回して、各自「あなたの役職」を確認します。<br>
      2) 夜フェーズは端末を役職保有者に回して行動（人狼は複数回投票して決定）。<br>
      3) 昼は死者の発表→議論→投票。進行は画面の指示に従ってください。
    </p>
  </div>

  <div id="game" class="card hidden">
    <h2 id="phaseTitle">ゲームを開始しました</h2>
    <div class="center">
      <div id="turnInfo" style="margin-bottom:8px"></div>
      <div id="playerReveal" class="card" style="max-width:460px;margin:0 auto"></div>
    </div>

    <div id="board" style="display:flex;gap:12px;margin-top:12px">
      <div style="flex:1">
        <h3>プレイヤー</h3>
        <div id="players" class="player-list"></div>
      </div>
      <div style="flex:1">
        <h3>ログ</h3>
        <div id="log" class="log"></div>

        <h3 style="margin-top:10px">操作</h3>
        <div id="actionsArea"></div>
      </div>
    </div>

    <div style="margin-top:12px" class="center">
      <button id="nextPhaseBtn" class="big">次へ</button>
      <button id="downloadBtn" class="secondary">状態をコピー（JSON）</button>
    </div>
  </div>

  <div id="help" class="card" style="margin-top:12px">
    <h2>ルール補足（省略版）</h2>
    <ul>
      <li>本実装はローカル端末を順に回す方式です。秘密を守って遊んでください。</li>
      <li>採用されている役職：<strong>人狼×2／占い師（霊能含む）／狩人（ボディガード）／魔女（救済＋毒）／狂人／ハンター／村人</strong>など。</li>
      <li>細かい挙動は画面の説明に従ってください（投票は端末を回して各自入力します）。</li>
    </ul>
  </div>
</main>

<footer>作成：ChatGPT — ローカルで遊べる簡易版（端末を回して進行してください）</footer>

<script>
/*
  シンプルな人狼ゲーム（ローカル端末パス回し）
  - 目的：ローカルで10人前後のゲームを楽しめる
  - 役職（チェックで有効化）：Werewolf(人狼) x2 (デフォルト) / Seer(占い師) / Medium(霊能者) /
    Bodyguard(狩人) / Witch(魔女) / Hunter(ハンター) / Madman(狂人)
  - 流れ（自動制御）：
    1) 役職配布 → 各プレイヤーに役職を見せる（端末を回す）
    2) 夜フェーズ：人狼の襲撃決定 → 占い師の判定 → 狩人の護衛 → 魔女の救済/毒 → 死亡確定
    3) 昼フェーズ：死亡者公開 → 議論 → 投票 → 処刑（ハンターの発動チェック）
    4) 勝利判定
*/

// ---------- 役職定義 ----------
const ROLE_DEFS = [
  { id: 'werewolf', name: '人狼', desc: '夜に1人を襲撃できる（襲撃決定は人狼同士の多数決）' },
  { id: 'seer', name: '占い師', desc: '夜に1人の正体（人狼かどうか）を知れる' },
  { id: 'medium', name: '霊能者', desc: '処刑された者が人狼かどうかを知れる（翌日）' },
  { id: 'bodyguard', name: '狩人（ガード）', desc: '毎晩1人を守る（連続護衛はルール次第）' },
  { id: 'witch', name: '魔女', desc: '救済（1回）と毒（1回）を使える' },
  { id: 'hunter', name: 'ハンター', desc: '処刑や襲撃で死んだとき、即座に誰か1人を射殺できる' },
  { id: 'madman', name: '狂人', desc: '人狼側の味方だが襲撃はできない。占いでは人間と出る' },
];
const DEFAULT_INCLUDED = ['werewolf','seer','medium','bodyguard','witch','hunter','madman'];

// ---------- UI要素 ----------
const roleOptions = document.getElementById('roleOptions');
const assignBtn = document.getElementById('assignBtn');
const resetBtn = document.getElementById('resetBtn');
const playerCountInput = document.getElementById('playerCount');
const namesInput = document.getElementById('names');

const setupDiv = document.getElementById('setup');
const gameDiv = document.getElementById('game');
const playerReveal = document.getElementById('playerReveal');
const playersDiv = document.getElementById('players');
const logDiv = document.getElementById('log');
const actionsArea = document.getElementById('actionsArea');
const phaseTitle = document.getElementById('phaseTitle');
const turnInfo = document.getElementById('turnInfo');
const nextPhaseBtn = document.getElementById('nextPhaseBtn');
const downloadBtn = document.getElementById('downloadBtn');

let state = null;

// 初期役職オプション描画
function renderRoleOptions(){
  roleOptions.innerHTML = '';
  ROLE_DEFS.forEach(r=>{
    const chk = document.createElement('label');
    chk.className='role-checkbox';
    chk.innerHTML = `<input type="checkbox" data-role="${r.id}" ${DEFAULT_INCLUDED.includes(r.id)?'checked':''}> ${r.name} — <span class="muted">${r.desc}</span>`;
    roleOptions.appendChild(chk);
  });
}
renderRoleOptions();

// ---------- ヘルパー ----------
function log(msg){ const p = document.createElement('div'); p.textContent = msg; logDiv.prepend(p); }
function randInt(n){ return Math.floor(Math.random()*n); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=randInt(i+1);[a[i],a[j]]=[a[j],a[i]]} return a }
function idToPlayer(id){ return state.players.find(p=>p.id===id) }

// ---------- ゲーム初期化 ----------
assignBtn.addEventListener('click', ()=>{
  const n = parseInt(playerCountInput.value) || 10;
  if(n<6 || n>12){ alert('プレイヤー人数は6〜12の範囲で指定してください'); return; }

  // 役職選択
  const selected = Array.from(roleOptions.querySelectorAll('input[type=checkbox]'))
    .filter(c=>c.checked).map(c=>c.dataset.role);

  // 名前リスト
  let names = [];
  const raw = namesInput.value.trim();
  if(raw.length>0){
    names = raw.split(',').map(s=>s.trim()).filter(s=>s.length>0);
  }
  while(names.length < n){
    names.push('Player' + (names.length+1));
  }
  names = names.slice(0,n);

  // 基本配役（人狼は2体を保証。人数に応じて人狼数調整したいが今回は2体固定）
  let roles = [];
  if(selected.includes('werewolf')){
    roles.push('werewolf');
    roles.push('werewolf'); // デフォルト2匹
  }
  selected.forEach(r=>{
    if(r!=='werewolf') roles.push(r);
  });
  // 足りない分は村人
  while(roles.length < n) roles.push('villager');
  // もし役職が多すぎる場合はトリム（右側）
  if(roles.length > n) roles = roles.slice(0,n);

  // シャッフルして割り当て
  roles = shuffle(roles);
  const players = names.map((nm,idx)=>{
    return {
      id: 'p'+(idx+1),
      name: nm,
      role: roles[idx],
      alive: true,
      protected: false,
      savedByWitch: false,
      poisonedByWitch: false
    };
  });

  // 初期state
  state = {
    players,
    day: 0,
    phase: 'reveal', // reveal -> night -> day -> vote -> end
    log: [],
    witch: { saveUsed:false, poisonUsed:false },
    pending: {
      werewolfVotes: {},
      seerCheck: null,
      guardTarget: null,
      witchSave: false,
      witchPoisonTarget: null,
      nightVictim: null,
      dayVotes: {}
    }
  };

  // show setup->game
  setupDiv.classList.add('hidden');
  gameDiv.classList.remove('hidden');
  logDiv.innerHTML='';
  renderPlayers();
  state.log.push('ゲーム開始。プレイヤー: ' + players.map(p=>p.name).join(', '));
  log('ゲーム開始。役職はランダム割り当て済み。端末を順に回して確認してください。');
  phaseTitle.textContent = '役職確認（端末を順に回して表示）';
  turnInfo.textContent = 'プレイヤー1から順に「役職を見る」を押してください';
  currentRevealIndex = 0;
  showRevealScreen();
});

// ---------- プレイヤー表示 ----------
function renderPlayers(){
  playersDiv.innerHTML = '';
  state.players.forEach(p=>{
    const el = document.createElement('div');
    el.className = 'player-card '+(p.alive?'alive':'dead');
    if(!p.alive) el.classList.add('dead');
    el.innerHTML = `<strong>${p.name}</strong><div style="font-size:13px" class="muted">${p.id}</div>
      <div style="margin-top:6px">状態: ${p.alive?'<span style="color:#86efac">生存</span>':'<span style="color:#f87171">死亡</span>'}</div>
      <div style="margin-top:6px;font-size:13px">役職: ${p.alive?'<span class="muted">秘密</span>':'<span class="muted">公開済</span>'}</div>`;
    playersDiv.appendChild(el);
  });
}

// ---------- 役職確認（端末パス回し） ----------
let currentRevealIndex = 0;
function showRevealScreen(){
  const p = state.players[currentRevealIndex];
  playerReveal.innerHTML = `
    <div class="center">
      <h3>プレイヤー ${currentRevealIndex+1}：${p.name}</h3>
      <p class="muted">端末は他の人に見せないでください。自分の役職のみ確認します。</p>
      <div style="margin-top:8px;padding:12px;background:#061426;border-radius:8px">
        <div style="font-size:16px"><strong>あなたの役職：</strong></div>
        <div style="font-size:20px;margin-top:6px">${displayRoleName(p.role)}</div>
        <div class="muted" style="margin-top:6px">${displayRoleDesc(p.role)}</div>
      </div>
      <div style="margin-top:10px">
        <button id="revealNextBtn">確認した。次の人へ</button>
      </div>
    </div>
  `;
  document.getElementById('revealNextBtn').addEventListener('click', ()=>{
    currentRevealIndex++;
    if(currentRevealIndex < state.players.length){
      showRevealScreen();
    } else {
      // 全員確認済み。開始
      state.phase = 'night';
      state.day = 0;
      startNight();
    }
  });
}

function displayRoleName(r){
  if(r==='villager') return '村人';
  const def = ROLE_DEFS.find(x=>x.id===r);
  return def ? def.name : r;
}
function displayRoleDesc(r){
  if(r==='villager') return '特殊能力なし。発言と投票で人狼を見つける。';
  const def = ROLE_DEFS.find(x=>x.id===r);
  return def ? def.desc : '';
}

// ---------- 夜フェーズ ----------
function startNight(){
  state.day++;
  state.phase = 'night';
  state.pending = {
    werewolfVotes: {},
    seerCheck: null,
    guardTarget: null,
    witchSave: false,
    witchPoisonTarget: null,
    nightVictim: null,
    dayVotes: {}
  };
  phaseTitle.textContent = `夜 ${state.day}日目`;
  turnInfo.textContent = '夜フェーズ：役職を持つ人に端末を回して行動してください';
  actionsArea.innerHTML = '';
  renderPlayers();
  log(`--- 夜 ${state.day} ---`);
  // シーケンス：人狼 -> 占い師 -> 狩人 -> 魔女 -> 結果処理
  prepareWerewolfPhase();
}

// 人狼フェーズ
function prepareWerewolfPhase(){
  const wolves = state.players.filter(p=>p.role==='werewolf' && p.alive);
  if(wolves.length===0){
    log('人狼がいません（全滅）。夜はスキップされます。');
    proceedAfterWerewolf();
    return;
  }

  actionsArea.innerHTML = `<div class="card"><strong>人狼の行動</strong>
    <p class="muted">人狼の方は端末を回して、襲撃対象を投票してください。<br>複数の人狼がいる場合は多数決で決定されます。</p>
    <div id="werewolfAction"></div>
    </div>`;

  const container = document.getElementById('werewolfAction');
  // 投票用UI（端末を人狼に渡して1票ずつ入れてもらう方式）
  container.innerHTML = `<div class="muted">（端末を1人ずつ人狼に渡して投票）</div>`;
  const voteBtn = document.createElement('button');
  voteBtn.textContent = '人狼に投票する（票を入れる）';
  voteBtn.addEventListener('click', ()=>openWerewolfVoteModal());
  container.appendChild(voteBtn);

  const doneBtn = document.createElement('button');
  doneBtn.className='secondary';
  doneBtn.style.marginLeft='8px';
  doneBtn.textContent = '決定（投票終了）';
  doneBtn.addEventListener('click', ()=>proceedAfterWerewolf());
  container.appendChild(doneBtn);
  updateWerewolfVoteSummary();
}

function openWerewolfVoteModal(){
  // 誰が投票しているか選択
  const aliveWolfIds = state.players.filter(p=>p.role==='werewolf' && p.alive).map(p=>p.id);
  // Choose voter - show a select to choose which werewolf is holding the device (so we can prevent double voting by same wolf)
  const modal = document.createElement('div');
  modal.style.position='fixed'; modal.style.left=0; modal.style.top=0; modal.style.right=0; modal.style.bottom=0;
  modal.style.background='rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
  modal.innerHTML = `<div style="background:#0b1624;padding:16px;border-radius:10px;min-width:320px">
    <h3>人狼の投票</h3>
    <label>あなたは誰ですか？
      <select id="wolfVoter">${aliveWolfIds.map(id=>`<option value="${id}">${idToPlayer(id).name}</option>`).join('')}</select>
    </label>
    <label style="display:block;margin-top:8px">襲撃対象：
      <select id="wolfTarget">${state.players.filter(p=>p.alive).map(p=>`<option value="${p.id}">${p.name}</option>`).join('')}</select>
    </label>
    <div style="margin-top:10px;text-align:right">
      <button id="wolfConfirm">投票</button>
      <button id="wolfCancel" class="secondary">キャンセル</button>
    </div>
  </div>`;
  document.body.appendChild(modal);
  document.getElementById('wolfCancel').addEventListener('click', ()=>modal.remove());
  document.getElementById('wolfConfirm').addEventListener('click', ()=>{
    const voter = document.getElementById('wolfVoter').value;
    const target = document.getElementById('wolfTarget').value;
    state.pending.werewolfVotes[voter] = target;
    log(`${idToPlayer(voter).name}（人狼）が ${idToPlayer(target).name} に投票しました`);
    modal.remove();
    updateWerewolfVoteSummary();
  });
}

function updateWerewolfVoteSummary(){
  const area = document.getElementById('werewolfAction');
  if(!area) return;
  // show tally
  const tally = {};
  Object.values(state.pending.werewolfVotes).forEach(t=>tally[t]=(tally[t]||0)+1);
  const keys = Object.keys(tally);
  let summary = '<div style="margin-top:8px"><strong>現在の集計：</strong><br>';
  if(keys.length===0) summary += '<span class="muted">まだ票が入っていません</span>';
  else {
    keys.forEach(k=>{
      summary += `${idToPlayer(k).name}：${tally[k]}票<br>`;
    });
  }
  summary += '</div>';
  area.querySelector('.voteSummary')?.remove();
  const div = document.createElement('div'); div.className='voteSummary'; div.innerHTML = summary;
  area.appendChild(div);
}

function proceedAfterWerewolf(){
  // 決定：最多票の対象をnightVictimに設定（同票はランダムで選ぶ）
  const votes = Object.values(state.pending.werewolfVotes);
  if(votes.length===0){
    state.pending.nightVictim = null;
    log('人狼の襲撃は実行されませんでした（票なし）。');
  } else {
    const tally = {};
    votes.forEach(v=>tally[v]=(tally[v]||0)+1);
    let max = 0;
    Object.keys(tally).forEach(k=>{ if(tally[k]>max) max=tally[k]; });
    const top = Object.keys(tally).filter(k=>tally[k]===max);
    const chosen = top[randInt(top.length)];
    state.pending.nightVictim = chosen;
    log(`人狼候補： ${top.map(k=>idToPlayer(k).name).join(', ')} → 決定： ${idToPlayer(chosen).name}`);
  }
  // 次：占い師
  prepareSeerPhase();
}

// 占い師
function prepareSeerPhase(){
  const seer = state.players.find(p=>p.role==='seer' && p.alive);
  if(!seer){
    log('占い師不在または死亡。占いはスキップされます。');
    proceedAfterSeer();
    return;
  }
  actionsArea.innerHTML = `<div class="card"><strong>占い師の行動</strong>
    <p class="muted">占い師の方は端末を受け取り、占う相手を選んでください（誰でも可）。</p>
    <div id="seerAction"></div>
    </div>`;
  const c = document.getElementById('seerAction');
  const select = document.createElement('select');
  state.players.filter(p=>p.alive && p.id!==seer.id).forEach(p=>{
    select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
  });
  c.appendChild(select);
  const btn = document.createElement('button'); btn.textContent='占う';
  btn.addEventListener('click', ()=>{
    const target = select.value;
    const isWere = idToPlayer(target).role === 'werewolf';
    state.pending.seerCheck = { by: seer.id, target, result: isWere ? '人狼' : '人間' };
    log(`占い：${idToPlayer(seer.id).name} が ${idToPlayer(target).name} を占いました（結果：${state.pending.seerCheck.result}）`);
    // 占い結果は占い師のみが見るので、モーダルで表示
    alert(`${idToPlayer(seer.id).name} さんへ：\n${idToPlayer(target).name} の判定は「${state.pending.seerCheck.result}」です。`);
    proceedAfterSeer();
  });
  c.appendChild(btn);
}

function proceedAfterSeer(){
  // 狩人
  prepareGuardPhase();
}

// 狩人（ボディガード）
function prepareGuardPhase(){
  const guard = state.players.find(p=>p.role==='bodyguard' && p.alive);
  if(!guard){
    log('狩人不在または死亡。護衛はスキップされます。');
    proceedAfterGuard();
    return;
  }
  actionsArea.innerHTML = `<div class="card"><strong>狩人の行動</strong>
    <p class="muted">狩人（ガード）の方は端末を受け取り、護衛する相手を1人選んでください（自分も可）。</p>
    <div id="guardAction"></div>
    </div>`;
  const c = document.getElementById('guardAction');
  const select = document.createElement('select');
  state.players.filter(p=>p.alive).forEach(p=> select.innerHTML += `<option value="${p.id}">${p.name}</option>`);
  c.appendChild(select);
  const btn = document.createElement('button'); btn.textContent='護衛する';
  btn.addEventListener('click', ()=>{
    state.pending.guardTarget = select.value;
    log(`狩人：${idToPlayer(guard.id).name} が ${idToPlayer(select.value).name} を護衛します`);
    proceedAfterGuard();
  });
  c.appendChild(btn);
}

function proceedAfterGuard(){
  // 魔女
  prepareWitchPhase();
}

// 魔女
function prepareWitchPhase(){
  const witch = state.players.find(p=>p.role==='witch' && p.alive);
  if(!witch){
    log('魔女不在または死亡。魔女はスキップされます。');
    resolveNight();
    return;
  }
  actionsArea.innerHTML = `<div class="card"><strong>魔女の行動</strong>
    <p class="muted">魔女の方は端末を受け取り、救済（1回）と毒（1回）を使うか選べます。</p>
    <div id="witchAction"></div>
    </div>`;
  const c = document.getElementById('witchAction');
  const victimId = state.pending.nightVictim;
  if(victimId){
    c.innerHTML += `<div>人狼の襲撃対象は <strong>${idToPlayer(victimId).name}</strong> です。</div>`;
  } else {
    c.innerHTML += `<div class="muted">今回の襲撃対象は未確定（または票なし）です。</div>`;
  }
  // show save option if not used
  const saveBtn = document.createElement('button'); saveBtn.textContent = '救済（use: '+(state.witch.saveUsed?'済':'未')+')';
  saveBtn.disabled = state.witch.saveUsed || !victimId;
  saveBtn.addEventListener('click', ()=> {
    state.witch.saveUsed = true; state.pending.witchSave = true;
    log(`魔女は救済を使用しました（${idToPlayer(victimId).name} を救済）`);
    // show confirmation modal
    alert('魔女：救済を実行しました。');
    prepareWitchPoisonPhase();
  });
  c.appendChild(saveBtn);

  const poisonBtn = document.createElement('button'); poisonBtn.textContent='毒（use: '+(state.witch.poisonUsed?'済':'未')+')';
  poisonBtn.style.marginLeft='8px';
  poisonBtn.disabled = state.witch.poisonUsed;
  poisonBtn.addEventListener('click', ()=> {
    // choose a poison target (alive except witch)
    const modal = document.createElement('div');
    modal.style.position='fixed'; modal.style.left=0; modal.style.top=0; modal.style.right=0; modal.style.bottom=0;
    modal.style.background='rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
    modal.innerHTML = `<div style="background:#0b1624;padding:16px;border-radius:10px;min-width:320px">
      <h3>魔女の毒：対象選択</h3>
      <label>対象：
        <select id="poisonTarget">${state.players.filter(p=>p.alive && p.id!==witch.id).map(p=>`<option value="${p.id}">${p.name}</option>`).join('')}</select>
      </label>
      <div style="margin-top:10px;text-align:right">
        <button id="poisonConfirm">実行（毒）</button>
        <button id="poisonCancel" class="secondary">キャンセル</button>
      </div>
    </div>`;
    document.body.appendChild(modal);
    document.getElementById('poisonCancel').addEventListener('click', ()=>modal.remove());
    document.getElementById('poisonConfirm').addEventListener('click', ()=>{
      const t = document.getElementById('poisonTarget').value;
      state.witch.poisonUsed = true;
      state.pending.witchPoisonTarget = t;
      log(`魔女は ${idToPlayer(t).name} に毒を使いました`);
      modal.remove();
      prepareWitchPoisonPhase();
    });
  });
  c.appendChild(poisonBtn);

  const skipBtn = document.createElement('button'); skipBtn.className='secondary'; skipBtn.style.marginLeft='8px'; skipBtn.textContent='何もしない';
  skipBtn.addEventListener('click', ()=> { log('魔女は何もしませんでした'); prepareWitchPoisonPhase(); });
  c.appendChild(skipBtn);
}

function prepareWitchPoisonPhase(){
  // after witch's choices, resolve night
  resolveNight();
}

// 夜の結果処理
function resolveNight(){
  const victim = state.pending.nightVictim;
  const guard = state.pending.guardTarget;
  const witchSaved = state.pending.witchSave;
  const witchPoison = state.pending.witchPoisonTarget;

  // Determine final deaths array
  let deaths = [];

  if(victim){
    let saved = false;
    if(guard && guard === victim){
      saved = true;
      log(`${idToPlayer(guard).name} が護衛して襲撃を防ぎました`);
    }
    if(witchSaved && victim){
      saved = true;
      log(`魔女の救済で ${idToPlayer(victim).name} は生き残りました`);
    }
    if(!saved){
      // victim dies unless witch poisoned them instead; check also if witch poisoned same target (then both)
      deaths.push(victim);
    }
  }

  if(witchPoison){
    deaths.push(witchPoison);
  }

  // Remove duplicates & only alive ones
  deaths = Array.from(new Set(deaths)).filter(id => idToPlayer(id) && idToPlayer(id).alive);

  // Apply deaths (but process hunter special)
  // We'll mark dead and then check for hunter immediate shot
  state.pending.nightDeaths = deaths;
  // Apply deaths but hold off on final messaging until hunter processing
  // For simplicity, mark them dead now
  deaths.forEach(id=>{
    const p = idToPlayer(id);
    p.alive = false;
    log(`<夜の死> ${p.name}（${displayRoleName(p.role)}）が夜に死亡しました`);
  });

  // If any hunter died, handle immediate shot
  const hunters = state.players.filter(p=>deaths.includes(p.id) && p.role==='hunter');
  if(hunters.length>0){
    // For each hunter, let them pick a target immediately
    // We'll process them sequentially by prompting the facilitator to pass device to the hunter (now dead) to choose target
    handleHuntersImmediateShot(hunters.slice());
  } else {
    // proceed to day
    startDay();
  }
}

// ハンターの即時射撃（夜に死んだ場合）
function handleHuntersImmediateShot(list){
  const hunterId = list.shift();
  if(!hunterId) { startDay(); return; }
  alert(`※ ハンター ${idToPlayer(hunterId).name} が夜に死亡しました。即座に1人を射殺できます。端末を ${idToPlayer(hunterId).name} に渡してターゲットを選んでもらってください。`);
  // modal to pick target
  const modal = document.createElement('div');
  modal.style.position='fixed'; modal.style.left=0; modal.style.top=0; modal.style.right=0; modal.style.bottom=0;
  modal.style.background='rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
  modal.innerHTML = `<div style="background:#0b1624;padding:16px;border-radius:10px;min-width:320px">
    <h3>ハンターの報復（即時射殺）</h3>
    <label>対象（生存者から選択）：
      <select id="hunterTarget">${state.players.filter(p=>p.alive).map(p=>`<option value="${p.id}">${p.name}</option>`).join('')}</select>
    </label>
    <div style="margin-top:10px;text-align:right">
      <button id="hunterConfirm">射殺</button>
    </div>
  </div>`;
  document.body.appendChild(modal);
  document.getElementById('hunterConfirm').addEventListener('click', ()=>{
    const t = document.getElementById('hunterTarget').value;
    const tp = idToPlayer(t);
    tp.alive = false;
    log(`ハンター ${idToPlayer(hunterId).name} の報復により ${tp.name}（${displayRoleName(tp.role)}） が射殺されました`);
    modal.remove();
    // If that target is also a hunter and alive? If they die, chain? We can check recursively
    const extraHunters = [];
    if(tp.role==='hunter'){
      extraHunters.push(tp.id);
    }
    // chain handle extra if any
    if(extraHunters.length>0){
      handleHuntersImmediateShot(extraHunters.concat(list));
    } else {
      handleHuntersImmediateShot(list);
    }
  });
}

// ---------- 昼フェーズ ----------
function startDay(){
  state.phase = 'day';
  phaseTitle.textContent = `昼 ${state.day}日目`;
  turnInfo.textContent = '昼フェーズ：死亡者の発表→議論→投票';
  renderPlayers();
  actionsArea.innerHTML = '';

  // show dead from night
  const dead = state.pending.nightDeaths || [];
  if(dead.length>0){
    dead.forEach(id=>{
      const p = idToPlayer(id);
      log(`昼の発表： ${p.name}（${displayRoleName(p.role)}） が死亡しました`);
    });
  } else {
    log('昼の発表：今夜の犠牲者はいませんでした');
  }

  // If medium (霊能者) alive, they can check last executed? Here medium can check last処刑 or last死者? We'll allow medium to inspect any one dead person (役職を知る)
  const medium = state.players.find(p=>p.role==='medium' && p.alive);
  if(medium && dead.length>0){
    // show medium action: pass device to medium to see dead's role
    actionsArea.innerHTML = `<div class="card"><strong>霊能者の行動</strong>
      <p class="muted">霊能者（生存）は、死者1名の正体を確認できます。端末を霊能者に渡して確認してください。</p>
      <div id="mediumAction"></div>
    </div>`;
    const c = document.getElementById('mediumAction');
    const select = document.createElement('select');
    dead.forEach(d=> select.innerHTML += `<option value="${d}">${idToPlayer(d).name}</option>`);
    c.appendChild(select);
    const btn = document.createElement('button'); btn.textContent='確認';
    btn.addEventListener('click', ()=>{
      const t = select.value;
      alert(`霊能者：${idToPlayer(t).name} の正体は ${displayRoleName(idToPlayer(t).role)} です。`);
      log(`霊能者が ${idToPlayer(t).name} の正体を確認しました`);
      // proceed to voting
      prepareDayVote();
    });
    c.appendChild(btn);
  } else {
    prepareDayVote();
  }
}

// 投票（昼）
function prepareDayVote(){
  actionsArea.innerHTML = `<div class="card"><strong>昼の投票（処刑）</strong>
    <p class="muted">端末を順に回して投票してください。自分に投票することは禁止（セルフ投票は無効）。</p>
    <div id="dayVoteArea"></div>
  </div>`;
  const c = document.getElementById('dayVoteArea');
  const btn = document.createElement('button'); btn.textContent='投票開始（順に入力）';
  btn.addEventListener('click', ()=>startCollectDayVotes());
  c.appendChild(btn);
}

function startCollectDayVotes(){
  state.pending.dayVotes = {};
  collectVoteForIndex(0);
}

function collectVoteForIndex(idx){
  const aliveList = state.players.filter(p=>p.alive);
  if(idx >= aliveList.length){
    // all votes collected
    finalizeDayVotes();
    return;
  }
  const voter = aliveList[idx];
  // show modal to voter
  const modal = document.createElement('div');
  modal.style.position='fixed'; modal.style.left=0; modal.style.top=0; modal.style.right=0; modal.style.bottom=0;
  modal.style.background='rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
  modal.innerHTML = `<div style="background:#0b1624;padding:16px;border-radius:10px;min-width:320px">
    <h3>投票（昼）</h3>
    <div class="muted">あなた：${voter.name}</div>
    <label>誰に投票しますか？
      <select id="voteTarget">${state.players.filter(p=>p.alive && p.id!==voter.id).map(p=>`<option value="${p.id}">${p.name}</option>`).join('')}</select>
    </label>
    <div style="margin-top:10px;text-align:right">
      <button id="voteConfirm">投票</button>
    </div>
  </div>`;
  document.body.appendChild(modal);
  document.getElementById('voteConfirm').addEventListener('click', ()=>{
    const t = document.getElementById('voteTarget').value;
    state.pending.dayVotes[voter.id] = t;
    log(`${voter.name} が ${idToPlayer(t).name} に投票しました`);
    modal.remove();
    collectVoteForIndex(idx+1);
  });
}

// 昼の投票確定
function finalizeDayVotes(){
  const votes = Object.values(state.pending.dayVotes);
  if(votes.length===0){
    log('投票が行われませんでした。');
    startNight(); // proceed
    return;
  }
  const tally = {};
  votes.forEach(v=>tally[v]=(tally[v]||0)+1);
  let max = 0;
  Object.keys(tally).forEach(k=>{ if(tally[k]>max) max=tally[k]; });
  const top = Object.keys(tally).filter(k=>tally[k]===max);
  const chosen = top[randInt(top.length)];
  const victim = idToPlayer(chosen);
  // lynch
  victim.alive = false;
  log(`昼の処刑： ${victim.name}（${displayRoleName(victim.role)}） が処刑されました`);
  // if lynched is hunter -> immediate shot
  if(victim.role==='hunter'){
    alert(`処刑されたハンター ${victim.name} は最後の力で1人を射殺できます。端末を ${victim.name} に渡して対象を選んでもらってください。`);
    // similar modal
    const modal = document.createElement('div');
    modal.style.position='fixed'; modal.style.left=0; modal.style.top=0; modal.style.right=0; modal.style.bottom=0;
    modal.style.background='rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
    modal.innerHTML = `<div style="background:#0b1624;padding:16px;border-radius:10px;min-width:320px">
      <h3>ハンター（最後の射殺）</h3>
      <label>対象（生存者から）：
        <select id="hunterTargetDay">${state.players.filter(p=>p.alive).map(p=>`<option value="${p.id}">${p.name}</option>`).join('')}</select>
      </label>
      <div style="margin-top:10px;text-align:right">
        <button id="hunterConfirmDay">射殺</button>
      </div>
    </div>`;
    document.body.appendChild(modal);
    document.getElementById('hunterConfirmDay').addEventListener('click', ()=>{
      const t = document.getElementById('hunterTargetDay').value;
      idToPlayer(t).alive = false;
      log(`ハンター ${victim.name} の遺恨により ${idToPlayer(t).name} が射殺されました`);
      modal.remove();
      checkWinAndNext();
    });
  } else {
    checkWinAndNext();
  }
}

// 勝利判定
function checkWinAndNext(){
  // Count
  const wolvesAlive = state.players.filter(p=>p.alive && p.role==='werewolf').length;
  const othersAlive = state.players.filter(p=>p.alive && p.role!=='werewolf').length;
  if(wolvesAlive===0){
    endGame('村人陣営の勝利！');
    return;
  }
  if(wolvesAlive >= othersAlive){
    endGame('人狼陣営の勝利！');
    return;
  }
  // 続行（夜へ）
  startNight();
}

// 終了処理
function endGame(msg){
  state.phase = 'end';
  phaseTitle.textContent = 'ゲーム終了';
  turnInfo.textContent = msg;
  actionsArea.innerHTML = `<div class="card"><h3>${msg}</h3><p class="muted">全役職を公開します。</p>
    <div>${state.players.map(p=>`${p.name} — ${displayRoleName(p.role)}`).join('<br>')}</div>
    <div style="margin-top:8px"><button id="restartBtn">最初に戻る（リセット）</button></div>
  </div>`;
  document.getElementById('restartBtn').addEventListener('click', ()=>location.reload());
  log('ゲーム終了：' + msg);
  renderPlayers();
}

// 次へボタンの機能（補助的）
nextPhaseBtn.addEventListener('click', ()=>{
  if(!state) return;
  if(state.phase === 'reveal') { showRevealScreen(); }
  else if(state.phase === 'night'){ resolveNight(); }
  else if(state.phase === 'day'){ prepareDayVote(); }
  else if(state.phase === 'end'){ /* nothing */ }
});

// ダウンロード（状態コピー）
downloadBtn.addEventListener('click', ()=>{
  if(!state) return;
  const s = JSON.stringify(state, null, 2);
  prompt('状態のJSON（コピーして保存可）', s);
});

// リセット
resetBtn.addEventListener('click', ()=> location.reload());

</script>
</body>
</html>
